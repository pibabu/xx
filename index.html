<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ey-IOS</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              terminal: {
                bg: '#000000',
                text: '#ffffff',
                prompt: '#4ade80',
                input: '#facc15',
                error: '#ef4444',
                success: '#10b981'
              }
            }
          }
        }
      }
    </script>
</head>
<body class="bg-terminal-bg text-terminal-text font-mono h-screen overflow-hidden">
  <div class="container mx-auto h-full flex flex-col">
    <!-- Status bar -->
    <div class="px-2 py-1 border-b border-gray-800 flex items-center justify-between text-sm">
      <div class="flex items-center space-x-2">
        <div id="status-indicator" class="w-2 h-2 rounded-full bg-terminal-error"></div>
        <span id="status-text" class="text-xs text-gray-500">Disconnected</span>
      </div>
      <button id="reconnect-btn" class="text-xs text-terminal-prompt hover:underline hidden" onclick="connectWebSocket()">
        Reconnect
      </button>
    </div>
    <!-- Chat history container -->
    <div id="chat-history" class="flex-1 overflow-y-auto p-4 space-y-4 scrollbar-hide">
      <div class="text-gray-500 text-sm">
        <span class="text-terminal-prompt">System:</span> Terminal chat initialized. Waiting for connection...
      </div>
    </div>
    
    <!-- Input area -->
    <div class="p-4 border-t border-gray-800">
      <div class="flex items-center">
        <span class="text-terminal-prompt mr-2">></span>
        <input
          id="user-input" 
          type="text" 
          class="bg-transparent flex-1 text-terminal-input outline-none caret-terminal-prompt" 
          autofocus 
          placeholder="_"
          onkeydown="handleInputKey(event)"
        >
      </div>
    </div>
  </div>
  <style>
    .scrollbar-hide::-webkit-scrollbar {
      width: 3px;
    }
    .scrollbar-hide::-webkit-scrollbar-thumb {
      background: rgba(74, 222, 128, 0.2);
      border-radius: 10px;
    }
    .scrollbar-hide::-webkit-scrollbar-thumb:hover {
      background: rgba(74, 222, 128, 0.3);
    }
    .scrollbar-hide::-webkit-scrollbar-track {
      background: transparent;
    }
    /* Firefox scrollbar */
    .scrollbar-hide {
      scrollbar-width: thin;
      scrollbar-color: rgba(74, 222, 128, 0.2) transparent;
    }
    /* Markdown styles */
    .markdown-content h1 { font-size: 1.5em; font-weight: bold; margin: 0.5em 0; color: #4ade80; }
    .markdown-content h2 { font-size: 1.3em; font-weight: bold; margin: 0.5em 0; color: #4ade80; }
    .markdown-content h3 { font-size: 1.1em; font-weight: bold; margin: 0.5em 0; color: #4ade80; }
    .markdown-content strong { font-weight: bold; color: #facc15; }
    .markdown-content em { font-style: italic; color: #a78bfa; }
    .markdown-content code { background: #1a1a1a; padding: 2px 6px; border-radius: 3px; color: #10b981; font-family: monospace; }
    .markdown-content pre { background: #1a1a1a; padding: 12px; border-radius: 6px; overflow-x: auto; margin: 0.5em 0; }
    .markdown-content pre code { background: transparent; padding: 0; color: #10b981; }
    .markdown-content ul { list-style: disc; margin-left: 1.5em; margin: 0.5em 0; }
    .markdown-content ol { list-style: decimal; margin-left: 1.5em; margin: 0.5em 0; }
    .markdown-content li { margin: 0.25em 0; }
    .markdown-content blockquote { border-left: 3px solid #4ade80; padding-left: 1em; color: #9ca3af; margin: 0.5em 0; }
    .markdown-content a { color: #60a5fa; text-decoration: underline; }
    .markdown-content hr { border: 0; border-top: 1px solid #374151; margin: 1em 0; }
    .markdown-content p { margin: 0.5em 0; }
  </style>

  <script>
    let ws = null;
    let currentMessageId = null;

    // DEBUG: Log everything to console
    console.log('üöÄ Script initialized');
    console.log('üìç Current URL:', window.location.href);

    // Markdown parser
    function parseMarkdown(text) {
      let html = text;
      
      // Code blocks (must be before inline code)
      html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
        return `<pre><code>${escapeHtml(code.trim())}</code></pre>`;
      });
      
      // Inline code
      html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
      
      // Headers
      html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
      html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
      html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
      
      // Bold
      html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
      html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');
      
      // Italic
      html = html.replace(/\*([^\*]+)\*/g, '<em>$1</em>');
      html = html.replace(/_([^_]+)_/g, '<em>$1</em>');
      
      // Links
      html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
      
      // Blockquotes
      html = html.replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>');
      
      // Horizontal rules
      html = html.replace(/^---$/gm, '<hr>');
      html = html.replace(/^\*\*\*$/gm, '<hr>');
      
      // Unordered lists
      html = html.replace(/^\* (.*$)/gm, '<li>$1</li>');
      html = html.replace(/^- (.*$)/gm, '<li>$1</li>');
      html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
      
      // Ordered lists
      html = html.replace(/^\d+\. (.*$)/gm, '<li>$1</li>');
      
      // Line breaks to paragraphs
      html = html.replace(/\n\n/g, '</p><p>');
      html = html.replace(/\n/g, '<br>');
      
      // Wrap in paragraph if not already wrapped in block element
      if (!html.match(/^<(h|pre|ul|ol|blockquote|hr)/)) {
        html = '<p>' + html + '</p>';
      }
      
      return html;
    }

    // Update connection status UI
    function updateStatus(connected) {
      console.log('üîÑ updateStatus called:', connected);
      const indicator = document.getElementById('status-indicator');
      const statusText = document.getElementById('status-text');
      const reconnectBtn = document.getElementById('reconnect-btn');
      const input = document.getElementById('user-input');

      if (connected) {
        indicator.className = 'w-2 h-2 rounded-full bg-terminal-success';
        statusText.textContent = 'Connected';
        reconnectBtn.classList.add('hidden');
        input.disabled = false;
        input.placeholder = '_';
        console.log('‚úÖ Status set to CONNECTED');
      } else {
        indicator.className = 'w-2 h-2 rounded-full bg-terminal-error';
        statusText.textContent = 'Disconnected';
        reconnectBtn.classList.remove('hidden');
        input.disabled = true;
        input.placeholder = 'Disconnected...';
        console.log('‚ùå Status set to DISCONNECTED');
      }
    }

    // Append message to chat history
    function appendMessage(role, content, messageId = null) {
      console.log('üí¨ appendMessage:', { role, content: content.substring(0, 50), messageId });
      const chatHistory = document.getElementById('chat-history');
      
      if (messageId && document.getElementById(messageId)) {
        // Update existing message
        const existingMsg = document.getElementById(messageId);
        if (role === 'ai') {
          existingMsg.querySelector('.message-content').innerHTML = parseMarkdown(content);
        } else {
          existingMsg.querySelector('.message-content').textContent = content;
        }
      } else {
        // Create new message
        const messageDiv = document.createElement('div');
        messageDiv.id = messageId || `msg-${Date.now()}`;
        
        if (role === 'user') {
          messageDiv.innerHTML = `
            <div class="flex items-start space-x-2">
              <span class="text-terminal-prompt">You:</span>
              <span class="message-content text-terminal-input">${escapeHtml(content)}</span>
            </div>
          `;
        } else if (role === 'ai') {
          messageDiv.innerHTML = `
            <div class="flex items-start space-x-2">
              <span class="text-terminal-prompt">LLM:</span>
              <span class="message-content markdown-content text-gray-300">${parseMarkdown(content)}</span>
            </div>
          `;
        } else if (role === 'tool') {
          messageDiv.innerHTML = `
            <div class="flex items-start space-x-2">
              <span class="text-yellow-500">üîß</span>
              <span class="message-content text-yellow-400">${escapeHtml(content)}</span>
            </div>
          `;
        } else {
          messageDiv.innerHTML = `
            <div class="text-gray-500 text-sm">
              <span class="text-terminal-prompt">System:</span>
              <span class="message-content">${escapeHtml(content)}</span>
            </div>
          `;
        }
        
        chatHistory.appendChild(messageDiv);
      }
      
      chatHistory.scrollTop = chatHistory.scrollHeight;
    }

    // Escape HTML to prevent XSS
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Connect to WebSocket server
    function connectWebSocket() {
      console.log('üîå connectWebSocket() called');
      
      // Check if already connected
      if (ws) {
        console.log('üìä Existing WebSocket state:', ws.readyState, {
          0: 'CONNECTING',
          1: 'OPEN',
          2: 'CLOSING',
          3: 'CLOSED'
        }[ws.readyState]);
      }
      
      if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('‚ö†Ô∏è Already connected, skipping');
        return;
      }
      
      if (ws && ws.readyState === WebSocket.CONNECTING) {
        console.log('‚ö†Ô∏è Connection in progress, skipping');
        return;
      }

      appendMessage('system', 'Connecting to server...');
      
      const urlParams = new URLSearchParams(window.location.search);
      const userHash = urlParams.get('hash');
      
      console.log('üîë User hash from URL:', userHash);
      
      if (!userHash) {
        console.error('‚ùå No user hash provided!');
        alert('No user hash provided! Add ?hash=YOUR_HASH to URL');
        return;
      }
      
      const wsUrl = `wss://ey-ios.com/ws/${userHash}`;
      console.log('üåê Connecting to:', wsUrl);
      
      try {
        ws = new WebSocket(wsUrl);
        console.log('‚ú® WebSocket object created');
      } catch (error) {
        console.error('‚ùå Failed to create WebSocket:', error);
        appendMessage('system', `Failed to create connection: ${error.message}`);
        return;
      }

      ws.onopen = () => {
        console.log('üéâ WebSocket CONNECTED!');
        appendMessage('system', 'Connected to chat server');
        updateStatus(true);
      };

      ws.onmessage = function(event) {
        console.log('üì® Message received:', event.data);
        
        try {
          const data = JSON.parse(event.data);
          console.log('üì¶ Parsed data:', data);
          
          if (data.type === 'start') {
            console.log('üü¢ AI message START');
            currentMessageId = `msg-${Date.now()}`;
            appendMessage('ai', '', currentMessageId);
          } 
          else if (data.type === 'token') {
            console.log('üìù Token received:', data.content);
            const existingMsg = document.getElementById(currentMessageId);
            if (existingMsg) {
              const contentSpan = existingMsg.querySelector('.message-content');
              contentSpan.textContent += data.content;
            } else {
              console.error('‚ùå Message element not found:', currentMessageId);
            }
          }
          else if (data.type === 'end') {
            console.log('üî¥ AI message END');
            // Parse the accumulated text as markdown
            const existingMsg = document.getElementById(currentMessageId);
            if (existingMsg) {
              const contentSpan = existingMsg.querySelector('.message-content');
              const text = contentSpan.textContent;
              contentSpan.innerHTML = parseMarkdown(text);
            }
            currentMessageId = null;
          }
          else if (data.type === 'error') {
            console.error('‚ùå Error from server:', data.message);
            appendMessage('system', `Error: ${data.message}`);
          }
          else {
            console.warn('‚ö†Ô∏è Unknown message type:', data.type);
          }
        } catch (error) {
          console.error('‚ùå Failed to parse message:', error);
        }
      };

      ws.onerror = (error) => {
        console.error('‚ùå WebSocket ERROR:', error);
        appendMessage('system', 'Connection error occurred');
      };

      ws.onclose = (event) => {
        console.log('üîå WebSocket CLOSED:', {
          code: event.code,
          reason: event.reason,
          wasClean: event.wasClean
        });
        appendMessage('system', 'Connection closed');
        updateStatus(false);
        currentMessageId = null;
      };
    }

    // Send message via WebSocket
    function sendMessage() {
      console.log('üì§ sendMessage() called');
      
      const input = document.getElementById('user-input');
      const message = input.value.trim();
      
      console.log('üìù Input value:', message);
      console.log('üìù Message length:', message.length);
      
      if (!message) {
        console.log('‚ö†Ô∏è Message is empty, returning');
        return;
      }
      
      console.log('üîç Checking WebSocket state...');
      console.log('  ws exists:', !!ws);
      console.log('  ws.readyState:', ws ? ws.readyState : 'N/A');
      console.log('  WebSocket.OPEN:', WebSocket.OPEN);
      
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.error('‚ùå WebSocket not open!');
        appendMessage('system', 'Not connected. Click Reconnect to try again.');
        return;
      }
      
      console.log('‚úÖ WebSocket is open, sending message...');
      
      const payload = JSON.stringify({ message });
      console.log('üì¶ Sending payload:', payload);
      
      try {
        ws.send(payload);
        console.log('‚úÖ Message sent successfully!');
        appendMessage('user', message);
        input.value = '';
      } catch (error) {
        console.error('‚ùå Failed to send message:', error);
        appendMessage('system', `Failed to send: ${error.message}`);
      }
    }

    // Handle input key events
    function handleInputKey(event) {
      console.log('‚å®Ô∏è Key pressed:', event.key);
      if (event.key === 'Enter') {
        console.log('‚Ü©Ô∏è Enter key detected, calling sendMessage()');
        sendMessage();
      }
    }

    // Auto-connect and focus input on page load
    window.addEventListener('load', () => {
      console.log('üåç Window LOAD event fired');
      const input = document.getElementById('user-input');
      input.disabled = false;
      input.focus();
      console.log('üîå Calling connectWebSocket() from load event');
      connectWebSocket();
    });

    // Reconnect and focus input on window focus if disconnected
    window.addEventListener('focus', () => {
      console.log('üëÅÔ∏è Window FOCUS event fired');
      if (!ws || ws.readyState === WebSocket.CLOSED) {
        console.log('üîå Reconnecting...');
        connectWebSocket();
      }
      const input = document.getElementById('user-input');
      input.focus();
    });

    // Enable input when typing
    document.addEventListener('keydown', (e) => {
      const input = document.getElementById('user-input');
      if (document.activeElement !== input && e.key.length === 1) {
        console.log('üéØ Focusing input from keydown');
        input.focus();
      }
    });

    // Debug info on startup
    console.log('üîß Debug mode enabled');
    console.log('üìã WebSocket states:', {
      CONNECTING: WebSocket.CONNECTING,
      OPEN: WebSocket.OPEN,
      CLOSING: WebSocket.CLOSING,
      CLOSED: WebSocket.CLOSED
    });
  </script>
</body>
</html>