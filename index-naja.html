<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ey-IOS</title>
    <!-- Comprehensive favicon support -->
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon.png">
    <link rel="shortcut icon" href="./favicon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              terminal: {
                bg: '#000000',
                text: '#ffffff',
                prompt: '#4ade80',
                input: '#facc15',
                error: '#ef4444',
                success: '#10b981'
              }
            }
          }
        }
      }
    </script>
</head>
<body class="bg-terminal-bg text-terminal-text font-mono h-screen overflow-hidden">
  <div class="container mx-auto h-full flex flex-col">
    <!-- Status bar -->
    <div class="px-2 py-1 border-b border-gray-800 flex items-center justify-between text-sm">
      <div class="flex items-center space-x-2">
        <div id="status-indicator" class="w-2 h-2 rounded-full bg-terminal-error"></div>
        <span id="status-text" class="text-xs text-gray-500">Disconnected</span>
      </div>
      <button id="reconnect-btn" class="text-xs text-terminal-prompt hover:underline hidden" onclick="connectWebSocket()">
        Reconnect
      </button>
    </div>
    
    <!-- Chat history container -->
    <div id="chat-history" class="flex-1 overflow-y-auto p-4 space-y-4 scrollbar-hide">
      <div class="text-gray-500 text-sm">
        <span class="text-terminal-prompt">System:</span> Terminal chat initialized. Waiting for connection...
      </div>
    </div>
    
    <!-- Input area -->
    <div class="p-4 border-t border-gray-800">
      <div class="flex items-center">
        <span class="text-terminal-prompt mr-2">></span>
        <input
          id="user-input" 
          type="text" 
          class="bg-transparent flex-1 text-terminal-input outline-none caret-terminal-prompt" 
          autofocus 
          placeholder="_"
          onkeydown="handleInputKey(event)"
        >
      </div>
    </div>
  </div>

  <style>
    /* Custom scrollbar */
    .scrollbar-hide::-webkit-scrollbar {
      width: 3px;
    }
    .scrollbar-hide::-webkit-scrollbar-thumb {
      background: rgba(74, 222, 128, 0.2);
      border-radius: 10px;
      transition: background 0.2s;
    }
    .scrollbar-hide::-webkit-scrollbar-thumb:hover {
      background: rgba(74, 222, 128, 0.3);
    }
    .scrollbar-hide::-webkit-scrollbar-track {
      background: transparent;
    }
    /* Firefox scrollbar */
    .scrollbar-hide {
      scrollbar-width: thin;
      scrollbar-color: rgba(74, 222, 128, 0.2) transparent;
    }
    
    /* Markdown styles */
    .markdown-content h1 { font-size: 1.5em; font-weight: bold; margin: 0.5em 0; color: #4ade80; }
    .markdown-content h2 { font-size: 1.3em; font-weight: bold; margin: 0.5em 0; color: #4ade80; }
    .markdown-content h3 { font-size: 1.1em; font-weight: bold; margin: 0.5em 0; color: #4ade80; }
    .markdown-content strong { font-weight: bold; color: #facc15; }
    .markdown-content em { font-style: italic; color: #a78bfa; }
    .markdown-content code { background: #1a1a1a; padding: 2px 6px; border-radius: 3px; color: #10b981; font-family: monospace; }
    .markdown-content pre { background: #1a1a1a; padding: 12px; border-radius: 6px; overflow-x: auto; margin: 0.5em 0; }
    .markdown-content pre code { background: transparent; padding: 0; color: #10b981; }
    .markdown-content ul { list-style: disc; margin-left: 1.5em; margin: 0.5em 0; }
    .markdown-content ol { list-style: decimal; margin-left: 1.5em; margin: 0.5em 0; }
    .markdown-content li { margin: 0.25em 0; }
    .markdown-content blockquote { border-left: 3px solid #4ade80; padding-left: 1em; color: #9ca3af; margin: 0.5em 0; }
    .markdown-content a { color: #60a5fa; text-decoration: underline; }
    .markdown-content hr { border: 0; border-top: 1px solid #374151; margin: 1em 0; }
    .markdown-content p { margin: 0.5em 0; }
    
    /* Cursor animation */
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
    .terminal-cursor {
      animation: blink 1s infinite;
    }
  </style>

  <script>
    const DEBUG = true;
    const log = (...args) => DEBUG && console.log(...args);
    
    let ws = null;
    let currentMessageId = null;
    let reconnectAttempts = 0;
    let maxReconnectAttempts = 5;
    let reconnectDelay = 1000;

    log('ðŸš€ Script initialized');
    log('ðŸ“ Current URL:', window.location.href);

    // Improved Markdown parser
    function parseMarkdown(text) {
      let html = text;
      
      // Code blocks (must be before inline code)
      html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
        return `<pre><code>${escapeHtml(code.trim())}</code></pre>`;
      });
      
      // Inline code
      html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
      
      // Headers
      html = html.replace(/^### (.*$)/gm, '<h3>$1</h3>');
      html = html.replace(/^## (.*$)/gm, '<h2>$1</h2>');
      html = html.replace(/^# (.*$)/gm, '<h1>$1</h1>');
      
      // Bold and italic
      html = html.replace(/\*\*([^\*]+)\*\*/g, '<strong>$1</strong>');
      html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');
      html = html.replace(/\*([^\*]+)\*/g, '<em>$1</em>');
      html = html.replace(/_([^_]+)_/g, '<em>$1</em>');
      
      // Links
      html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
      
      // Blockquotes
      html = html.replace(/^> (.*$)/gm, '<blockquote>$1</blockquote>');
      
      // Horizontal rules
      html = html.replace(/^(---|\*\*\*)$/gm, '<hr>');
      
      // Lists
      html = html.replace(/^[*-] (.*$)/gm, '<li>$1</li>');
      html = html.replace(/^\d+\. (.*$)/gm, '<li>$1</li>');
      html = html.replace(/(<li>.*<\/li>)/s, '<ul>$1</ul>');
      
      // Line breaks
      html = html.replace(/\n\n/g, '</p><p>');
      html = html.replace(/\n/g, '<br>');
      
      // Wrap in paragraph if not already wrapped
      if (!html.match(/^<(h|pre|ul|ol|blockquote|hr)/)) {
        html = '<p>' + html + '</p>';
      }
      
      return html;
    }

    function updateStatus(connected) {
      const indicator = document.getElementById('status-indicator');
      const statusText = document.getElementById('status-text');
      const reconnectBtn = document.getElementById('reconnect-btn');
      const input = document.getElementById('user-input');

      if (connected) {
        indicator.className = 'w-2 h-2 rounded-full bg-terminal-success';
        statusText.textContent = 'Connected';
        reconnectBtn.classList.add('hidden');
        input.disabled = false;
        input.placeholder = '_';
        reconnectAttempts = 0;
        log('âœ… Status: CONNECTED');
      } else {
        indicator.className = 'w-2 h-2 rounded-full bg-terminal-error';
        statusText.textContent = 'Disconnected';
        if (reconnectAttempts < maxReconnectAttempts) {
          statusText.textContent += ` (Retrying in ${reconnectDelay/1000}s)`;
        }
        reconnectBtn.classList.remove('hidden');
        input.disabled = true;
        input.placeholder = 'Disconnected...';
        log('âŒ Status: DISCONNECTED');
      }
    }

    function appendMessage(role, content, messageId = null) {
      const chatHistory = document.getElementById('chat-history');
      
      if (messageId && document.getElementById(messageId)) {
        const existingMsg = document.getElementById(messageId);
        const contentSpan = existingMsg.querySelector('.message-content');
        if (role === 'ai') {
          contentSpan.innerHTML = parseMarkdown(content);
        } else {
          contentSpan.textContent = content;
        }
      } else {
        const messageDiv = document.createElement('div');
        messageDiv.id = messageId || `msg-${Date.now()}`;
        
        const roleConfig = {
          user: {
            prefix: 'You:',
            class: 'text-terminal-input',
            escape: true
          },
          ai: {
            prefix: 'LLM:',
            class: 'markdown-content text-gray-300',
            escape: false
          },
          tool: {
            prefix: 'ðŸ”§',
            class: 'text-yellow-400',
            escape: true
          },
          system: {
            prefix: 'System:',
            class: '',
            escape: true
          }
        };
        
        const config = roleConfig[role] || roleConfig.system;
        
        messageDiv.innerHTML = `
          <div class="flex items-start space-x-2">
            <span class="text-terminal-prompt">${config.prefix}</span>
            <span class="message-content ${config.class}">${config.escape ? escapeHtml(content) : parseMarkdown(content)}</span>
          </div>
        `;
        
        chatHistory.appendChild(messageDiv);
      }
      
      // Smooth scroll to bottom
      chatHistory.scrollTo({ top: chatHistory.scrollHeight, behavior: 'smooth' });
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function connectWebSocket(autoReconnect = false) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        log('âš ï¸ Already connected');
        return;
      }
      
      if (ws && ws.readyState === WebSocket.CONNECTING) {
        log('âš ï¸ Connection in progress');
        return;
      }

      const urlParams = new URLSearchParams(window.location.search);
      const userHash = urlParams.get('hash');
      
      if (!userHash) {
        const errorMsg = 'No user hash provided! Add ?hash=YOUR_HASH to URL';
        log('âŒ', errorMsg);
        if (!autoReconnect) alert(errorMsg);
        return;
      }
      
      if (!autoReconnect) {
        appendMessage('system', 'Connecting to server...');
      }
      
      const wsUrl = `wss://ey-ios.com/ws/${userHash}`;
      log('ðŸŒ Connecting to:', wsUrl);
      
      try {
        ws = new WebSocket(wsUrl);
        
        ws.onopen = () => {
          log('ðŸŽ‰ WebSocket CONNECTED!');
          appendMessage('system', 'Connected to chat server');
          updateStatus(true);
        };

        ws.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            
            switch(data.type) {
              case 'start':
                currentMessageId = `msg-${Date.now()}`;
                appendMessage('ai', '', currentMessageId);
                break;
              case 'token':
                const existingMsg = document.getElementById(currentMessageId);
                if (existingMsg) {
                  existingMsg.querySelector('.message-content').textContent += data.content;
                }
                break;
              case 'end':
                const msg = document.getElementById(currentMessageId);
                if (msg) {
                  const contentSpan = msg.querySelector('.message-content');
                  contentSpan.innerHTML = parseMarkdown(contentSpan.textContent);
                }
                currentMessageId = null;
                break;
              case 'error':
                appendMessage('system', `Error: ${data.message}`);
                break;
              default:
                log('âš ï¸ Unknown message type:', data.type);
            }
          } catch (error) {
            log('âŒ Failed to parse message:', error);
          }
        };

        ws.onerror = (error) => {
          log('âŒ WebSocket ERROR:', error);
          if (!autoReconnect) {
            appendMessage('system', 'Connection error occurred');
          }
        };

        ws.onclose = (event) => {
          log('ðŸ”Œ WebSocket CLOSED:', { code: event.code, reason: event.reason, wasClean: event.wasClean });
          updateStatus(false);
          currentMessageId = null;
          
          // Auto-reconnect with exponential backoff
          if (reconnectAttempts < maxReconnectAttempts && autoReconnect) {
            reconnectAttempts++;
            log(`ðŸ”„ Auto-reconnecting in ${reconnectDelay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
            setTimeout(() => connectWebSocket(true), reconnectDelay);
            reconnectDelay = Math.min(reconnectDelay * 2, 10000);
          }
        };
        
      } catch (error) {
        log('âŒ Failed to create WebSocket:', error);
        if (!autoReconnect) {
          appendMessage('system', `Failed to create connection: ${error.message}`);
        }
      }
    }

    function sendMessage() {
      const input = document.getElementById('user-input');
      const message = input.value.trim();
      
      if (!message) return;
      
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        appendMessage('system', 'Not connected. Click Reconnect to try again.');
        return;
      }
      
      try {
        ws.send(JSON.stringify({ message }));
        appendMessage('user', message);
        input.value = '';
      } catch (error) {
        appendMessage('system', `Failed to send: ${error.message}`);
      }
    }

    function handleInputKey(event) {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    }

    // Initialize
    window.addEventListener('load', () => {
      const input = document.getElementById('user-input');
      input.disabled = false;
      input.focus();
      connectWebSocket();
    });

    window.addEventListener('focus', () => {
      if (!ws || ws.readyState === WebSocket.CLOSED) {
        connectWebSocket();
      }
      document.getElementById('user-input').focus();
    });

    document.addEventListener('keydown', (e) => {
      const input = document.getElementById('user-input');
      if (document.activeElement !== input && e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
        input.focus();
      }
    });

    log('ðŸ”§ Terminal ready');
  </script>
</body>
</html>